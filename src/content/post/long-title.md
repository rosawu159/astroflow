---
title: "Sliding Window Maximum"
description: "This post is purely for Sliding Window Maximum"
publishDate: "01 Feb 2023"
tags: ["leetcode"]
---

## 需求

對於每個滑動窗口，當它向右移動一個位置時，我們要能快速找出該窗口內的最大值，並將這些最大值按順序存入一個結果數組中返回

## 思路

1. 暴力解法用兩層迴圈對每個滑動窗口進行遍歷，時間複雜度是 O(n * k)，對於很大的數組來說效率不高。

2. 如何有效地更新和刪除不必要的元素，以提升查找窗口中最大值的效率。

3. 滑動窗口移動時，有很多重複元素，只需要少量更新即可得到新的最大值。

4. 普通的 queue 只能進行單向操作，無法有效地在隊首和隊尾進行刪除。

5. deque 可以從隊首和隊尾進行插入和刪除，因此更適合解決滑動窗口問題。
   
    a. 利用 deque 的雙端操作，來高效地移除過期元素並確保隊首為最大值

    b. 雙端隊列使得我們能夠在 O(n) 的時間內完成所有操作，因為每個元素最多進入和離開 deque 各一次

## 資料結構

1. 用 deque 存窗口內元素的索引，而非元素本身

2. 每次滑動後，通過索引訪問 nums 時，用 nums[dq[0]] 就能得到當前窗口內的最大值

3. 維持隊列內的遞減性：

   a. 讓每次 deque 的隊首元素就是當前窗口的最大值
   
   b. 新元素加入 deque 時，從隊尾開始移除所有比當前元素小的元素。這樣可以確保隊列中只保留可能成為最大值的元素

4. 滑動時：

   a. 每次 dq 要加入新元素 nums[i] 時，先判斷 deque 中隊首的索引是否已經超出當前窗口範圍（i - k 之前），如果超出則移除

   b. 從隊尾開始移除所有小於當前元素 nums[i] 的索引，因為這些元素不可能再成為最大值

   c. 將當前元素的索引加入 deque

   d. 當滑動窗口內的元素都掃過一次後，將當前窗口的最大值 nums[dq[0]] 加入結果中

## 總結

使用 deque 在 O(n) 的時間內解決這道滑動窗口最大值問題。每個元素最多只會進入和離開 deque 各一次，因此時間複雜度是 O(n)，而空間複雜度是 O(k)，因為 deque 中最多只儲存 k 個索引值。
